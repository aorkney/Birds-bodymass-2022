# This script will produce diagnostic plots.
# The first plot will show how patterns of integration,
# within and across skeletal modules, evolve with sample size.
# This will be useful for assessing the minimum sample size that
# should be chosen for subsequent analyses. 
# This script will use output generated by
# Modularity_and_sample_size_10_08_2022.R


setwd('D:/Documents/Alex_birds/Ideas_2022/SICBY')
# Set the working directory.

size.scaling<-read.csv('size_scale_uncertainty_10_08_2022.csv')
size.scaling<-size.scaling[,-1]
size.scaling[size.scaling < 0 ]<-0
size.scaling.p<-read.csv('size_scale_uncertainty_p_10_08_2022.csv')
size.scaling.p<-size.scaling.p[,-1]
size.scaling.p[size.scaling.p < 0 ]<-0
# Load and prepare the required data.

library(ggplot2)
library(reshape2)
# Load packages to organise and plot data. 

within.head<-c(2)
# Define the indices for the bones in the head module.


wing.bones<-
combn(c('humerus','radius','ulna','carpometacarpus'),2) 
within.wing<-matrix(NA,1,dim(wing.bones)[2])
for(i in 1:dim(wing.bones)[2] ){
	within.wing[,i]<-intersect(grep(wing.bones[1,i],colnames(size.scaling)),
	grep(wing.bones[2,i],colnames(size.scaling)) )
}
within.wing<-as.vector(within.wing)
# Define the indices for the bones in the wing module. 

trunk.bones<-
combn(c('scapula','coracoid','sternum','synsacrum'),2) 
within.trunk<-matrix(NA,1,dim(trunk.bones)[2])
for(i in 1:dim(trunk.bones)[2] ){
	within.trunk[,i]<-intersect(grep(trunk.bones[1,i],colnames(size.scaling)),
	grep(trunk.bones[2,i],colnames(size.scaling)) )
}
within.trunk<-as.vector(within.trunk)
# Define the indices for the bones in the trunk module.

leg.bones<-
combn(c('femur','tibiotarsus','tarsometatarsus'),2) 
within.leg<-matrix(NA,1,dim(leg.bones)[2])
for(i in 1:dim(leg.bones)[2] ){
	within.leg[,i]<-intersect(grep(leg.bones[1,i],colnames(size.scaling)),
	grep(leg.bones[2,i],colnames(size.scaling)) )
}
within.leg<-as.vector(within.leg)
# Define the indices for the bones in the leg modules. 

modules<-c(within.head,within.wing,within.trunk,within.leg)

inc<-unique(size.scaling$sample.size)
# sample size values
mean.size.scaling<-matrix(NA,length(inc),7)
mean.size.scaling[,1]<-inc
colnames(mean.size.scaling)<-c('sample.size','head','wing','trunk','leg','crossmin','crossmax')
# prepare a matrix to recieve values. 


for(i in 1: length(inc) ){
	ind<-which(size.scaling$sample.size==inc[i])
	mean.size.scaling[i,2]<-mean( size.scaling[ind,within.head] )
	mean.size.scaling[i,3]<-mean( colMeans( size.scaling[ind,within.wing] ))
	mean.size.scaling[i,4]<-mean( colMeans( size.scaling[ind,within.trunk] ))
	mean.size.scaling[i,5]<-mean( colMeans( size.scaling[ind,within.leg] ))
	mean.size.scaling[i,6]<-min( colMeans( size.scaling[ind,-c(1,modules)]) )
	mean.size.scaling[i,7]<-max( colMeans( size.scaling[ind,-c(1,modules)]) )
}
# Assign mean values for modular integration at each level of sample size. 

df<-as.data.frame(mean.size.scaling)
molten.df<-melt(df,id='sample.size')
# Re-organise the data

cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# colour blind palette

mp<-
ggplot()+
geom_ribbon(aes(x=sample.size,ymin=crossmin,ymax=crossmax),fill='lightgrey',data=df )+
geom_line(aes(x=sample.size,y=value,group=variable,linetype=variable,col=variable),size=1,data=molten.df[-c(41:60),])+
scale_colour_manual(values=c('head'=cbbPalette[7],'wing'=cbbPalette[4],
'trunk'=cbbPalette[6],'leg'=cbbPalette[8]))+
geom_vline(xintercept=30,size=3/2)+
scale_x_continuous(breaks=inc)+
lims(y=c(0,11))+
labs(x=expression(italic('n')),y=expression(italic(Z)),colour='module',linetype='module')+
  theme(axis.line.x.bottom=element_line(size = 1, colour = "black"),
	axis.line.y.left=element_line(size = 1, colour = "black"),
      axis.text.x=element_text(size=15,colour='black'),
      axis.text.y=element_text(size=15,colour='black'),
	axis.title.x.bottom=element_text(size=20,colour="black"),
	axis.title.y.left=element_text(size=20,colour="black"),
      axis.ticks=element_line(size=2),
      legend.position="right",
      panel.background=element_blank(),
      panel.border=element_blank(),
      panel.grid.major=element_blank(),
      panel.grid.minor=element_blank(),
      plot.background=element_blank(),
	legend.key.width = unit(2, "cm"))
# This is a plot that demonstrates that the clarity of modular organisation within the avian skeleton
# increases towards an asymptote as the number of sampled birds increases.
# A sample size of 30 is sufficient for the mean pairwise effect sizes of integration within modules
# to routinely exceed the range of values of cross-module pairwise effect sizes of integration. 


library(ggnewscale)
# We need the ggnewscale package to superimpose different colourgradients. 

yvals<-c(4,6,7,8,9)
kseq<-seq(10,100,by=20)
mp2<-mp
for(k in 1:length(kseq)){
	recompile <- matrix(NA,13,13)
	rownames(recompile)<-c('skull','mandible','carpometacarpus','radius','ulna','humerus',
	'sternum','coracoid','scapula','synsacrum','femur','tibiotarsus','tarsometatarsus')
	colnames(recompile)<-rownames(recompile)

	for(i in 1:length(size.scaling[1,-1])  ){
		names<-colnames(size.scaling[,-1])
		x<-  sub("\\..*","", names)[i]
		y<-  sub(".*\\.","", names)[i]
		ind<-which(size.scaling$sample.size==kseq[k])
		recompile[which(rownames(recompile)==x),which(colnames(recompile)==y)]<-mean( size.scaling[ind,-1][,i] )
		recompile[which(rownames(recompile)==y),which(colnames(recompile)==x)]<-mean( size.scaling[ind,-1][,i] )
	}

	result.rev<-apply(t(recompile),2,rev)
	longData<-melt(result.rev)
	longData$value[which(longData$value<0)]<-0
	longData$Var1<-(as.numeric(longData$Var1)/(100/11))+yvals[k]
	longData$Var2<-as.numeric(longData$Var2)+kseq[k]-5

	mp2<- mp2+
	coord_fixed(ratio=100/11)+
  	geom_raster(aes(fill=value,x = Var2, y = Var1),data=longData)+
   	#scale_fill_gradientn(colours = c('darkblue','red','yellow') ,na.value="white")+
	scale_fill_gradientn(colours = c('yellow','red','black') ,na.value="white")+
	new_scale("fill") +
	theme(legend.position='none')
}
# This is an overlay with indicative microplots illustrating how the scheme of 
# pairwise integration across the avian skeleton becomes clearer with greater sample size. 


recompile <- matrix(NA,13,13)
rownames(recompile)<-c('skull','mandible','carpometacarpus','radius','ulna','humerus',
'sternum','coracoid','scapula','synsacrum','femur','tibiotarsus','tarsometatarsus')
colnames(recompile)<-rownames(recompile)

for(i in 1:length(size.scaling[1,-1])  ){
	names<-colnames(size.scaling[,-1])
	x<-  sub("\\..*","", names)[i]
	y<-  sub(".*\\.","", names)[i]
	ind<-which(size.scaling$sample.size==100)
	recompile[which(rownames(recompile)==x),which(colnames(recompile)==y)]<-mean( size.scaling[ind,-1][,i] )
	recompile[which(rownames(recompile)==y),which(colnames(recompile)==x)]<-mean( size.scaling[ind,-1][,i] )
}

result.rev<-apply(t(recompile),2,rev)
longData<-melt(result.rev)
longData$value[which(longData$value<0)]<-0

cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
bone_colours<-c(rep(cbbPalette[4],4),rep(cbbPalette[6],4),rep(cbbPalette[8],3),rep(cbbPalette[7],3))
bone_colours<-rev(c(rep(cbbPalette[7],2),rep(cbbPalette[4],4),rep(cbbPalette[6],4),rep(cbbPalette[8],3)))


mp3<-
ggplot(longData, aes(x = Var2, y = Var1)) + 
coord_fixed(ratio = 1, xlim = NULL, ylim = NULL, expand = TRUE, clip = "on")+
geom_tile(aes(fill=value)) + 
scale_fill_gradientn(colours = c('yellow','red','black') ,na.value="white")+
labs(fill = expression(italic(Z)))+
labs(x="", y="") +
theme_bw() + theme(axis.text.x=element_text(size=12, angle=90, vjust=0.3,colour=rev(bone_colours),face = "bold"),
axis.text.y=element_text(size=12,colour=(bone_colours),face = "bold"),
plot.title=element_text(size=11,hjust=.5), legend.position="bottom",
legend.key.width=unit(2,'cm'),
legend.title=element_text(size=20),
legend.text=element_text(size=16),
panel.background = element_blank())+
labs(fill = expression(italic(Z)))+
geom_hline(yintercept = 3.5,size=2,colour="black")+
geom_hline(yintercept = 11.5,size=2,colour="black")+
geom_hline(yintercept = 7.5,size=2,colour="black")+
geom_vline(xintercept = 10.5,size=2,colour="black")+
geom_line(data=as.data.frame(cbind(c(2.5,2.5),c(0.5,13.5))),aes(x=V1,y=V2),size=2,colour='black')+
geom_line(data=as.data.frame(cbind(c(6.5,6.5),c(0.5,13.5))),aes(x=V1,y=V2),size=2,colour='black')+
geom_line(data=as.data.frame(cbind(c(10.5,10.5),c(0.5,13.5))),aes(x=V1,y=V2),size=2,colour='black')+
scale_x_discrete(position = "top") 
# This is a plot of the overall pairwise scheme of integration across the skeleton when 
# the sample size is large. 

mp.legend<-cowplot::get_legend(mp)
# Make sure the cowplot package is installed. 


library(ggpubr)
# Load the ggpubr package to arrange plots.

dev.new(height=10,width=16.9,unit='cm')
ggarrange(mp3,mp2,cowplot::plot_grid(mp.legend),ncol=3,widths=c(1,1,0.25),labels=c('a','b'),
label.x=0.025,label.y=0.95,font.label=list(size=30))
# Produce a combined plot. 


# ggsave(filename='multiplot_sample_size_v_effect_size_modules_10_08_2022.pdf')
# save the plot


